package main

import (
	"fmt"
	"github.com/iancoleman/strcase"
	"os"
	"path/filepath"
	"strings"
)

var _defaultProtoPkgName = "pb"
func (g *Generator) buildProto(types []string, dir string) {
	var parts []string
	if *protoPkg == "" {
		*protoPkg = _defaultProtoPkgName
	}
	header := `// Code generated by \"enumer %s\"; DO NOT EDIT.
syntax = "proto3";
package %s;
%s
`
	if *protoGoPkg != "" {
		*protoGoPkg = fmt.Sprintf("option go_package = \"%s\";", *protoGoPkg)
	}
	parts = append(parts, fmt.Sprintf(header,  strings.Join(os.Args[1:], " "), *protoPkg, *protoGoPkg))
	// Run generate for each type.
	for _, typeName := range types {
		values := g.values(typeName, typeName, "screaming-snake", false)
		stanza := g.createProtoEnumStanza(values, typeName)
		parts = append(parts, stanza)
	}

	// Format the output.
	protoPath := *protoOutput
	if protoPath == "" {
		baseName := defaultBaseName
		if len(types) == 1 {
			baseName = types[0]
		}
		name := strings.ToLower(fmt.Sprintf("%s.proto", baseName))
		protoPath = filepath.Join(dir, *protoPkg, name)
	}
	text := strings.Join(parts, "\n")
	write(protoPath, []byte(text))
}

func (g *Generator) createProtoEnumStanza(values []Value, typeName string) string {
	tmpl := `enum %s {
%s
}
`
	var el []string
	for i, value := range values {
		n := value.name
		if i == 0 {
			if strings.ToLower(value.name) == "undefined" {
				n = strings.Join([]string{n, strcase.ToScreamingSnake(typeName)}, "_")
			}
		}
		el = append(el, fmt.Sprintf("    %s = %s;", n, value.str))
	}
	return fmt.Sprintf(tmpl, typeName, strings.Join(el, "\n"))
}
