package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/iancoleman/strcase"
)

var _defaultGraphqlPkgName = "pb"

func (g *Generator) buildGraphQL(types []string, dir string) {
	var parts []string
	if *graphqlPkg == "" {
		*graphqlPkg = _defaultGraphqlPkgName
	}
	header := "# Code generated by \"enumer %s\"; DO NOT EDIT.\n\n"
	parts = append(parts, fmt.Sprintf(header,  strings.Join(os.Args[1:], " ")))
	// Run generate for each type.
	for _, typeName := range types {
		enumName := strings.Title(g.pkg.name) + typeName
		if graphqlPrefix != nil && len(*graphqlPrefix) > 0 {
			enumName = *graphqlPrefix + typeName
		}
		values := g.values(typeName, "", "camel", false)
		stanza := g.createGraphQLEnumStanza(values, enumName)
		parts = append(parts, stanza)
	}

	// Format the output.
	graphqlPath := *graphqlOutput
	if graphqlPath == "" {
		baseName := defaultBaseName
		if len(types) == 1 {
			baseName = types[0]
		}
		name := strcase.ToSnake(fmt.Sprintf("%s_gen.graphql", baseName))
		graphqlPath = filepath.Join(dir, *graphqlDir, name)
	}
	text := strings.Join(parts, "\n")
	write(graphqlPath, []byte(text))
}

func (g *Generator) createGraphQLEnumStanza(values []Value, enumName string) string {
	tmpl := `enum %s {
%s
}
`
	var el []string
	for _, value := range values {
		n := value.name
		fmt.Println("value.name", value.name)
		el = append(el, fmt.Sprintf("    %s = %s;", n, value.str))
	}
	return fmt.Sprintf(tmpl, enumName, strings.Join(el, "\n"))
}
